Index: libvpx-1.1.0/vpx/src/vpx_image.c
===================================================================
--- libvpx-1.1.0.orig/vpx/src/vpx_image.c	2018-02-23 11:00:32.000000000 +0100
+++ libvpx-1.1.0/vpx/src/vpx_image.c	2018-02-23 11:25:45.197023478 +0100
@@ -12,6 +12,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include "vpx/vpx_image.h"
+#include "vpx/vpx_integer.h"
 
 #define ADDRESS_STORAGE_SIZE      sizeof(size_t)
 /*returns an addr aligned to the byte boundary specified by align*/
@@ -132,11 +133,10 @@
         break;
     }
 
-    /* Calculate storage sizes given the chroma subsampling */
-    align = (1 << xcs) - 1;
-    w = (d_w + align) & ~align;
-    align = (1 << ycs) - 1;
-    h = (d_h + align) & ~align;
+    /* Calculate storage sizes. If the buffer was allocated externally, the width
+     * and height shouldn't be adjusted. */
+    w = d_w;
+    h = d_h;
     s = (fmt & VPX_IMG_FMT_PLANAR) ? w : bps * w / 8;
     s = (s + stride_align - 1) & ~(stride_align - 1);
 
@@ -159,8 +159,22 @@
 
     if (!img_data)
     {
-        img->img_data = img_buf_memalign(buf_align, ((fmt & VPX_IMG_FMT_PLANAR)?
-                                         h * s * bps / 8 : h * s));
+        uint64_t alloc_size;
+        /* Calculate storage sizes given the chroma subsampling */
+        align = (1 << xcs) - 1;
+        w = (d_w + align) & ~align;
+        align = (1 << ycs) - 1;
+        h = (d_h + align) & ~align;
+
+        s = (fmt & VPX_IMG_FMT_PLANAR) ? w : bps * w / 8;
+        s = (s + stride_align - 1) & ~(stride_align - 1);
+        /* no VPX_IMG_FMT_HIGHBITDEPTH in this version, so stride_in_bytes = s */
+        //stride_in_bytes = (fmt & VPX_IMG_FMT_HIGHBITDEPTH) ? s * 2 : s;
+        alloc_size = (fmt & VPX_IMG_FMT_PLANAR) ? (uint64_t)h * s * bps / 8
+                                                : (uint64_t)h * s;
+        if(alloc_size != (size_t)alloc_size) goto fail;
+
+        img->img_data = img_buf_memalign(buf_align, (size_t)alloc_size);
         img->img_data_owner = 1;
     }
 
